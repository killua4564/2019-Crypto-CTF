import sys
import string
import hashlib
import itertools
from pwn import *
from sympy import invert, gcd

sys.setrecursionlimit(2047)

# conn = remote("167.71.62.250", "14559")

def proof():
	conn.recvuntil("such that ")
	hashfunc = conn.recvuntil("(X)").replace(b"(X)", b"").decode()
	conn.recvuntil(" = ")
	tailhash = conn.recvuntil("\n").strip(b"\n").decode()

	if 'md5' == hashfunc: func = hashlib.md5 
	elif 'sha1' == hashfunc: func = hashlib.sha1
	elif 'sha224' == hashfunc: func = hashlib.sha224
	elif 'sha256' == hashfunc: func = hashlib.sha256
	elif 'sha384' == hashfunc: func = hashlib.sha384
	elif 'sha512' == hashfunc: func = hashlib.sha512

	for length in range(1, 10):
		for x in itertools.product(string.digits + string.ascii_lowercase + string.ascii_uppercase, repeat=length):
			h = func(''.join(x).encode()).hexdigest()
			if h[-6:] == tailhash:
				conn.sendline(''.join(x))
				return

# |-------------------------------------|
# | Options:                         |
# |    [E]ncrypted message           |
# |    [K]ey generation function     |
# |    [S]end the decrypted message  |
# |    [T]ry encryption              |
# |    [Q]uit                        |
# |-------------------------------------|
# Send your Options:

# enc = (151932459406664309983798343084132298553008368360390463709500120041510458596865227177445086059969586459756550320877122622991584679336434087439801563265361661666109512086236798270012585030817773097429184688861801975445997950271026691334295198592884664804794704989036246799765956337278526180895211519L, 41003806502999270406608239094612266076135420265088346519794502629257460581604856626410755713475169138129108114380064798446408962314072411856068414801586788595075933296235561857857462234114598617132820175242905744978558511737518716278430983982946363945189599802809791323866373261444608463552739936L)

# def gen_key(e, nbit):
#     p = getPrime(nbit << 2)
#     q = getPrime(nbit >> 2)
#     print 'p =', p
#     print 'q =', q
#     n = p * q
#     return (e, n)

# Send your input as a pair (a, b):
# $ 11111,111111
# ((a + b âˆš-1) ** e) (mod n) = (52965818862952969866212327870299586063435866406371426696587212591607933586569173783675149711058546535550421820875460786781213254153415686299577731976552461921368555324831399818787544362557092793621851006004774442479916718833955649652657937737934252326977263992013758389042860597489167125255462704L, 361821204818981389075582112515082888192413743779263137399987507980096964855704214838526979798221523963836368854300284723452724102278544595077001383432164369188670860412573239128273945294373222070056218602414268295236909068912591232023196217292280244175313967991290213076353611837857341756977595348L)

def enc(a, b):
	conn.recvuntil(":")
	conn.sendline("T")
	conn.recvuntil(":")
	conn.sendline("%d,%d" % (a, b))
	conn.recvuntil(" = ")
	return eval(conn.recvuntil(")").decode().replace("L", ""))

def cadd(a, b, n):
	return ((a[0] + b[0]) % n, (a[1] + b[1]) % n)

def cmul(a, b, n):
	return ((a[0] * b[0] - a[1] * b[1]) % n, (a[0] * b[1] + a[1] * b[0]) % n)

def cpow(a, k, n):
	if k == 0:
		return (1, 0)
	if k == 1:
		return a
	if k % 2 == 0:
		return cpow(cmul(a, a, n), k // 2, n)
	else:
		return cmul(cpow(cmul(a, a, n), (k - 1) // 2, n), a, n)

if __name__ == '__main__':
	# proof()
	# print(enc(0, 1))
	# >>> e % 4 = 3

	c = (378122348642214690905411683807377396279362526734068034297186493255873563264253248095197659138069664908850853277799239471404715546747080714581633876343291058815268009173602365587463522797812239900814474973941995698621021680129530453282192603316731832323767320307650941745085796583822798379896337325, 205549984221850341303682190742446959375043769671555741781145106776498798455293849755553794941345135675348633855787880355726112506553703853175271830126908219803257875131387292937296039523359975622001865593227631119497003599166091642640101746534401068507972834895023584843991641629874709898672559632)

	# e2 = enc(2, 0)[0]
	e2 = 109030283585506503834793323306780495601936649247396370754206831260108117442869969186127390639917507483852682310859344932942346742830277982896041621811260240515554533048081121663241158174033169986054180789564744212852284148705585572931817609154318224426912424880542440459155843380566597403017076647

	# n = enc(-1, 0)[0] + 1
	n = 382975062010049587749620725513651749588184541624130114289222138159292339170632672668267212151775645905920781924053991145170626363543738851042520943347932362395498194409642569058718016346710828569360608539013922390877298763013691114651357975268009182684167852530766157912422559062884268456378656497
	p = 228517792080140341
	q = 1675909164550923263854591345270445396052847869117231939809062226222204253885693425526434134321712288675268468398852452684029376569327518089966506865838909486699078280423099271324646863671350838232140981094611254627738568184261530942469845202934677427234062382272736609418198352717

	for e in range(3, 99999, 4):
		if pow(2, e, n) == e2:
			print(f'e = {e}')
			break

	phi = (p * p - 1) * (q * q - 1) // gcd(p * p - 1, q * q - 1)
	d = int(invert(e, phi))
	
	# Send the decrypted message
	print(cpow(c, d, n))
	